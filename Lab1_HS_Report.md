# Лабораторна робота №1
## Вибір лідера в кільці: алгоритм Hirschberg-Sinclair (HS)

**Дисципліна:** Розподілені системи  
**Виконав(ла):** _Божевський Іван Петрович_  
**Група:** _ІНФ-1_  


## 1. Вступ
В данній лабораторній реалізовано алгоритм Hirschberg-Sinclair для задачі вибору лідера в кільцевій топології. Реалізацію виконано на основі окремих процесів C# із TCP-взаємодією на `localhost` та двома логічними напрямками пересилання (`left/right`).

## 2. Теоретична частина

### 2.1 Постановка задачі вибору лідера в кільці
Нехай існує множина процесів `P = {p0, p1, ..., pN-1}`, об'єднаних у логічне кільце.  
Кожен процес має:
1. Унікальний ідентифікатор `UID` (`UID != -1`).
2. Локальний стан (кандидат/некандидат, поточна фаза, службові прапорці).
3. Канали зв'язку із двома сусідами.

Потрібно знайти єдиного лідера `L`, для якого:
1. `UID(L) = max(UID(pi))` для всіх `pi` у кільці.
2. Після завершення алгоритму всі процеси знають `WinnerUID`.
3. Вибори завершуються за скінченний час без централізованого координатора.

### 2.2 Модель системи та припущення
Для даної лабораторної прийнято таку модель:
1. Процеси асинхронні: немає глобального такту або спільного годинника.
2. Передавання виконується TCP, тому доставка в межах з'єднання надійна та впорядкована.
3. Топологія фіксована під час одного запуску (кільце не перебудовується).
4. Відмови вузлів/мережі не моделюються.
5. Процеси стартують близько в часі, але можуть обробляти події з різними затримками.

Практичне відображення моделі у вашій роботі:
1. `Launcher` створює `N` окремих `Node`.
2. Кожен `Node` слухає порт `basePort + index`.
3. `UID` задаються наперед та гарантовано унікальні.

### 2.3 Ідея та складність HS (коротко)
HS виконує "експоненціальне зондування" кільця:
1. У фазі `k` кандидат перевіряє дистанцію `2^k` у двох напрямах.
2. Якщо жоден більший `UID` не "перебиває" кандидата, він переходить до наступної фази.
3. Кандидат із максимальним `UID` не може бути відсіяний і зрештою оголошує себе лідером.

Класичні оцінки:
1. Кількість фаз, через які проходить переможець: `O(log N)`.
2. Загальна кількість повідомлень у системі: `O(N log N)`.

## 3. Опис алгоритму HS

### 3.1 Фази `k`, дальність `2^k`
На початку кожен вузол потенційно є кандидатом.  
Для фази `k` кандидат із `uid = u` формує два повідомлення:
1. `OUT(u, k, LEFT, ttl = 2^k)`
2. `OUT(u, k, RIGHT, ttl = 2^k)`

Інтуїція:
1. Якщо `u` малий, його `OUT` швидко блокується вузлом із більшим `UID`.
2. Якщо `u` великий, його повідомлення проходять далі.
3. Максимальний `UID` поступово збільшує "радіус" перевірки до покриття всього кільця.

### 3.2 Повідомлення OUT/IN, hopCount/TTL, правила пересилання/розвороту
У реалізації використовуються чотири типи: `OUT`, `IN`, `ANNOUNCE`, `REPORT`.

Семантика `OUT`:
1. Несе `candidateUid`, `phase`, `direction`, `ttl`.
2. Рухається в одному напрямку, поки `ttl > 0`.
3. На кожному кроці `ttl = ttl - 1`.

Обробка `OUT` у вузлі `v`:
1. Якщо `candidateUid < uid(v)`, `OUT` відкидається.
2. Якщо `candidateUid > uid(v)` і `ttl > 0`, повідомлення пересилається далі.
3. Якщо `ttl == 0`, формується відповідь `IN` у зворотному напрямку.
4. Якщо `candidateUid == uid(v)` і повідомлення повернулося до ініціатора відповідної фази, це ознака успішного проходження кільця для цього кандидата (умова визначається вашою логікою стану фази).

Семантика `IN`:
1. `IN` підтверджує, що відповідний `OUT` дійшов до межі `2^k` і повертається до кандидата.
2. Кандидат очікує дві відповіді `IN` (з `LEFT` і `RIGHT`) у фазі `k`.
3. Після отримання двох `IN` кандидат переходить до фази `k+1`.

### 3.3 Умова перемоги та оголошення лідера (ANNOUNCE)
Процес із глобально максимальним `UID` є єдиним, кого не зупиняє правило `candidateUid < localUid`.  
Після досягнення умови перемоги (за станом вашої реалізації HS) вузол:
1. Встановлює локально `isLeader = true`.
2. Розсилає `ANNOUNCE(winnerUid = ownUid)` по кільцю.

Кожний вузол при `ANNOUNCE`:
1. Зберігає `WinnerUID`.
2. Пересилає `ANNOUNCE` далі (один раз, із захистом від дублювання).
3. Після завершення розповсюдження формує `REPORT` до `Launcher`.


## 4. Реалізація

### 4.1 Архітектура solution (Launcher/Node)
Склад системи:
1. `Launcher` (керуючий процес):
   - приймає параметри запуску (`N`, `basePort`, список `UID`, таймаути);
   - запускає `N` дочірніх процесів `Node`;
   - ініціює сценарій старту;
   - збирає `REPORT` та обчислює агреговані метрики.
2. `Node` (робочий процес):
   - піднімає TCP listener;
   - підключається до сусідів кільця;
   - серіалізує/десеріалізує line-delimited JSON;
   - виконує автомати станів HS (фази, отримання `IN`, перемога, `ANNOUNCE`).

Така декомпозиція дозволяє:
1. Відділити експериментальний контроль (`Launcher`) від алгоритму (`Node`).
2. Масштабувати `N` без зміни алгоритмічного коду.
3. Відтворювати запуск із однаковими параметрами.

### 4.2 Мережеве кільце (порти, left/right)
Нумерація вузлів: `i in [0, N-1]`.

Формули адресації:
1. `port(i) = basePort + i`
2. `left(i) = (i - 1 + N) mod N`
3. `right(i) = (i + 1) mod N`

Приклад для `N = 5`:
1. Для `i = 0`: `left = 4`, `right = 1`.
2. Для `i = 4`: `left = 3`, `right = 0`.

Транспорт:
1. TCP-з'єднання між сусідами на `127.0.0.1`.
2. Повідомлення закінчуються символом нового рядка (line-delimited JSON).
3. Кожен факт відправки через TCP рахується в `TotalMessages`.

### 4.3 Формат повідомлень (поля JSON)
Базова уніфікована форма:
```json
{
  "type": "OUT|IN|ANNOUNCE|REPORT",
  "candidateUid": 123,
  "senderUid": 123,
  "direction": "LEFT|RIGHT",
  "phase": 2,
  "ttl": 4,
  "winnerUid": 123,
  "rounds": 3,
  "totalMessages": 0,
  "timeMs": 0
}
```

### 4.4 Підрахунок метрик (WinnerUID/Rounds/TotalMessages)
Метрики сценарію:
1. `WinnerUID`:
   - джерело істини: `ANNOUNCE.winnerUid`;
   - очікування: однакове значення у всіх `REPORT`.
2. `Rounds`:
   - кількість фаз `k`, які пройшов лідер до моменту оголошення;
   - у звіті наводиться як ціле число.
3. `TotalMessages`:
   - сума всіх `send` у всіх `Node`;
   - одна операція `send` одного JSON-повідомлення = `+1`.
Практична схема агрегування:
1. Кожен `Node` веде локальний лічильник `localSendCount`.
2. Після завершення алгоритму відправляє `REPORT`.
3. `Launcher` обчислює `TotalMessages = sum(localSendCount)`.

### 4.5 Самоперевірка: winner == max(uid)
Після кожного запуску виконується автоматична перевірка:
1. `expected = max(UID list)`.
2. `actual = WinnerUID` з результатів.
3. Якщо `actual != expected`, результат запуску некоректний.

Додаткові перевірки цілісності:
1. Усі вузли повернули `REPORT`.
2. Усі `REPORT.winnerUid` однакові.
3. `Rounds >= 1` та `TotalMessages > 0`.

### 4.6 Псевдокод ядра HS (для реалізації Node)
```text
state:
  uid, phase = 0
  active = true
  gotInLeft[phase], gotInRight[phase] = false

onStart:
  send OUT(uid, phase, LEFT, 2^phase)
  send OUT(uid, phase, RIGHT, 2^phase)

onReceive OUT(cUid, k, dir, ttl):
  if cUid < uid:
    drop
  else if ttl > 0:
    forward OUT(cUid, k, dir, ttl - 1)
  else:
    send IN(cUid, k, reverse(dir))

onReceive IN(cUid, k, dir):
  if cUid != uid or k != phase:
    ignore as stale/foreign
  else:
    mark gotIn(dir)=true
    if gotInLeft[phase] and gotInRight[phase]:
      phase = phase + 1
      if winner condition reached:
        send ANNOUNCE(uid)
      else:
        send OUT(uid, phase, LEFT, 2^phase)
        send OUT(uid, phase, RIGHT, 2^phase)

onReceive ANNOUNCE(w):
  winnerUid = w
  if not announcedBefore:
    forward ANNOUNCE(w)
  finish and REPORT
```


## 5. Результати експериментів

Набір експериментів:
1. `N = 10`
2. `N = 20`
3. `N = 50`
4. `N = 100`

Очікувані результати:
1. Очікується повільне зростання `Rounds` зі збільшенням `N` (наближено логарифмічне).
2. `TotalMessages` зростає швидше за `Rounds`, оскільки в кожній фазі активні кандидати генерують по два `OUT`, а також зворотні `IN` та фінальний `ANNOUNCE`.

Таблиця результатів:

| N   | Rounds | TotalMessages | Winner UID | All UID`s
|-----|--------|---------------|-------------------|-------------------|
| 10  | 5      | 148           | 30689             |[30336,30536,15608,30416,30500,29824,30264,29820,4272,30680,14772,14236,13188,4140,30624,29956,22828,30188,1444,30484]|
| 20  | 6      | 362             | 30680             |[30336,30536,15608,30416,30500,29824,30264,29820,4272,30680,14772,14236,13188,4140,30624,29956,22828,30188,1444,30484]|
| 50  | 7      | 890             | 32184                 |[31724,24740,31212,31640,30576,30716,30964,4724,30628,30908,30092,31372,31676,30968,13392,31096,30656,5980,25044,31132,31360,14764,30824,18796,31272,31592,21172,11952,30868,31688,31136,29776,30152,30712,31652,31568,30856,21428,30852,2400,26728,31784,31820,31872,31928,31968,32012,32068,32132,32184]|
| 100 | 8      | 2007             | 35704                 |[33256,30224,29876,31164,34528,34568,34352,34712,34808,34300,34472,15052,32096,33440,32760,33296,14808,29752,31004,29640,33096,31840,31992,33124,30940,34412,30892,33384,29852,30400,32396,34348,31584,30788,30916,33456,8256,33704,32168,29832,31444,32784,26252,34216,32372,30524,25276,30796,20548,30044,33164,32056,33968,31620,30772,33836,30528,31328,31580,29784,32388,33752,34084,30912,30904,29896,4720,33892,30204,32492,34028,30316,28504,31028,30348,14668,32648,30536,14852,33092,34128,31668,33936,21288,31892,34780,34260,34916,34980,35060,35100,35168,35228,35292,35336,35372,35464,35520,35600,35704]|

## 6. Висновки
1. Реалізовано HS-вибори лідера у кільці на реальних процесах C# із TCP-взаємодією.
2. Протокол `OUT/IN/ANNOUNCE/REPORT` дозволяє прозоро відстежувати фази, переможця та фінальні метрики.
3. Ключовий критерій коректності `WinnerUID == max(UID)` формалізовано та придатно до автоматичної перевірки в `Launcher`.
4. Після заповнення таблиці фактичними даними можна обґрунтовано підтвердити емпіричну поведінку HS щодо фазності та повідомлень.
5. Реалізація придатна як база для подальших експериментів з навантаженням, серіалізацією і профілюванням мережевої взаємодії в межах тієї самої HS-моделі.

## 7. Посилання на проєкт
[GitHub](https://github.com/LironeA/DS_Lab1/)